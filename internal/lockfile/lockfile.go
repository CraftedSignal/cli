package lockfile

import (
	"fmt"
	"os"
	"time"

	"gopkg.in/yaml.v3"
)

// RuleState represents the sync state of a single rule.
type RuleState struct {
	File            string    `yaml:"file"`
	LastSyncedHash  string    `yaml:"last_synced_hash"`
	LastSyncedAt    time.Time `yaml:"last_synced_at"`
	PlatformVersion int       `yaml:"platform_version"`
}

// Lockfile represents the .csctl.lock file.
type Lockfile struct {
	Rules map[string]RuleState `yaml:"rules"`
}

// LockfileName is the name of the lockfile.
const LockfileName = ".csctl.lock"

// Load reads the lockfile from the current directory.
func Load() (*Lockfile, error) {
	data, err := os.ReadFile(LockfileName)
	if os.IsNotExist(err) {
		return &Lockfile{Rules: make(map[string]RuleState)}, nil
	}
	if err != nil {
		return nil, err
	}

	var lf Lockfile
	if err := yaml.Unmarshal(data, &lf); err != nil {
		return nil, err
	}

	if lf.Rules == nil {
		lf.Rules = make(map[string]RuleState)
	}

	return &lf, nil
}

// Save writes the lockfile to disk atomically via temp file + rename.
func (lf *Lockfile) Save() error {
	data, err := yaml.Marshal(lf)
	if err != nil {
		return err
	}

	header := []byte("# Auto-generated by csctl - commit this file\n")
	content := append(header, data...)

	// Write to temp file in current directory, then rename (atomic on POSIX)
	tmp, err := os.CreateTemp(".", ".csctl.lock.tmp.*")
	if err != nil {
		return fmt.Errorf("failed to create temp lockfile: %w", err)
	}
	tmpName := tmp.Name()

	if _, err := tmp.Write(content); err != nil {
		tmp.Close()
		os.Remove(tmpName)
		return fmt.Errorf("failed to write temp lockfile: %w", err)
	}
	if err := tmp.Close(); err != nil {
		os.Remove(tmpName)
		return fmt.Errorf("failed to close temp lockfile: %w", err)
	}
	if err := os.Rename(tmpName, LockfileName); err != nil {
		os.Remove(tmpName)
		return fmt.Errorf("failed to rename lockfile: %w", err)
	}

	return nil
}

// Update updates the state for a rule.
func (lf *Lockfile) Update(id, file, hash string, version int) {
	lf.Rules[id] = RuleState{
		File:            file,
		LastSyncedHash:  hash,
		LastSyncedAt:    time.Now(),
		PlatformVersion: version,
	}
}

// Get returns the state for a rule.
func (lf *Lockfile) Get(id string) (RuleState, bool) {
	state, ok := lf.Rules[id]
	return state, ok
}
