package lockfile

import (
	"os"
	"time"

	"gopkg.in/yaml.v3"
)

// RuleState represents the sync state of a single rule.
type RuleState struct {
	File            string    `yaml:"file"`
	LastSyncedHash  string    `yaml:"last_synced_hash"`
	LastSyncedAt    time.Time `yaml:"last_synced_at"`
	PlatformVersion int       `yaml:"platform_version"`
}

// Lockfile represents the .csctl.lock file.
type Lockfile struct {
	Rules map[string]RuleState `yaml:"rules"`
}

// LockfileName is the name of the lockfile.
const LockfileName = ".csctl.lock"

// Load reads the lockfile from the current directory.
func Load() (*Lockfile, error) {
	data, err := os.ReadFile(LockfileName)
	if os.IsNotExist(err) {
		return &Lockfile{Rules: make(map[string]RuleState)}, nil
	}
	if err != nil {
		return nil, err
	}

	var lf Lockfile
	if err := yaml.Unmarshal(data, &lf); err != nil {
		return nil, err
	}

	if lf.Rules == nil {
		lf.Rules = make(map[string]RuleState)
	}

	return &lf, nil
}

// Save writes the lockfile to disk.
func (lf *Lockfile) Save() error {
	data, err := yaml.Marshal(lf)
	if err != nil {
		return err
	}

	header := []byte("# Auto-generated by csctl - commit this file\n")
	return os.WriteFile(LockfileName, append(header, data...), 0644)
}

// Update updates the state for a rule.
func (lf *Lockfile) Update(id, file, hash string, version int) {
	lf.Rules[id] = RuleState{
		File:            file,
		LastSyncedHash:  hash,
		LastSyncedAt:    time.Now(),
		PlatformVersion: version,
	}
}

// Get returns the state for a rule.
func (lf *Lockfile) Get(id string) (RuleState, bool) {
	state, ok := lf.Rules[id]
	return state, ok
}
